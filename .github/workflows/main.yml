# name of the workflow as it appears in github actions ui
name: build & push (classic docker cli)

# workflow trigger: run on push to "main" branch
on:
  push:
    branches: ["main"]

# set environment variable for the docker image name (using secrets for username)
env:
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/dummy-app

jobs:
  docker:   # job name

    # specify the runner os
    runs-on: ubuntu-latest

    permissions:
      contents: write    # allow job to write git tags to the repo
      packages: write    # allow job to push docker images to registry

    steps:
      # step 1: checkout repo (full history for versioning)
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0    # fetch all history and tags

      # step 2: fetch all remote tags (get every version tag in git)
      - name: fetch all tags
        run: git fetch --tags --force --prune

      # step 3: detect the latest version tag using semantic versioning (e.g. 1.2.10)
      - name: detect latest version
        id: cur
        run: |
          latest=$(git tag --list | sort -V | tail -n1)   # sort tags, get highest
          echo "tag=${latest:-1.0.0}" >>"$GITHUB_OUTPUT"  # default to 1.0.0 if none

      # step 4: bump the patch version (e.g. 1.0.0 → 1.0.1)
      - name: bump patch
        id: bump
        uses: christian-draeger/increment-semantic-version@1.2.3
        with:
          current-version: ${{ steps.cur.outputs.tag }}    # use detected version
          version-fragment: patch                          # bump patch number

      # step 5: create and push new git tag if it doesn’t already exist
      - name: create & push git tag
        env:
          NEW: ${{ steps.bump.outputs.next-version }}
        run: |
          if git rev-parse -q --verify "refs/tags/$NEW" >/dev/null; then
            echo "tag $NEW already exists – skipping."   # avoid duplicate tags
            exit 0
          fi
          git tag "$NEW"                                # create new tag
          git push origin "$NEW"                        # push tag to remote

      # step 6: login to docker hub using classic cli and secrets
      - name: docker hub login
        run: echo "${{ secrets.DOCKERHUB_TOKEN }}" |
             docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

      # step 7: build docker image and tag it with both version and "latest"
      - name: build image
        run: |
          docker build -t $IMAGE_NAME:${{ steps.bump.outputs.next-version }} \
                       -t $IMAGE_NAME:latest .

      # step 8: push both versioned and "latest" tags to docker hub
      - name: push image
        run: |
          docker push $IMAGE_NAME:${{ steps.bump.outputs.next-version }}
          docker push $IMAGE_NAME:latest
